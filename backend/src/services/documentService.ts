import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export interface ReportData {
  title: string;
  clientName: string;
  reportPeriod: string;
  content: string;
  createdBy: string;
  createdAt: Date;
}

class DocumentService {
  async generateWordDocument(reportData: ReportData): Promise<Buffer> {
    try {
      const { title, clientName, reportPeriod, content, createdBy, createdAt } = reportData;

      // Create document
      const doc = new Document({
        sections: [
          {
            properties: {},
            children: [
              // Header
              new Paragraph({
                text: 'MONTHLY STATUS REPORT',
                heading: HeadingLevel.TITLE,
                alignment: AlignmentType.CENTER,
                spacing: { after: 400 },
              }),

              // Client info
              new Paragraph({
                children: [
                  new TextRun({
                    text: 'CLIENT NAME: ',
                    bold: true,
                  }),
                  new TextRun({
                    text: clientName.toUpperCase(),
                    bold: true,
                  }),
                ],
                spacing: { after: 200 },
              }),

              new Paragraph({
                children: [
                  new TextRun({
                    text: 'REPORTING PERIOD: ',
                    bold: true,
                  }),
                  new TextRun({
                    text: reportPeriod.toUpperCase(),
                    bold: true,
                  }),
                ],
                spacing: { after: 400 },
              }),

              // Content
              ...this.parseContentToParagraphs(content),

              // Footer
              new Paragraph({
                text: '',
                spacing: { before: 800 },
              }),

              new Paragraph({
                children: [
                  new TextRun({
                    text: `Report generated by: ${createdBy}`,
                    italics: true,
                    size: 20,
                  }),
                ],
                spacing: { after: 200 },
              }),

              new Paragraph({
                children: [
                  new TextRun({
                    text: `Generated on: ${createdAt.toLocaleDateString()}`,
                    italics: true,
                    size: 20,
                  }),
                ],
              }),
            ],
          },
        ],
      });

      // Generate buffer
      const buffer = await Packer.toBuffer(doc);
      return buffer;
    } catch (error) {
      console.error('Error generating Word document:', error);
      throw new Error('Failed to generate Word document');
    }
  }

  private parseContentToParagraphs(content: string): Paragraph[] {
    const paragraphs: Paragraph[] = [];
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmedLine = line.trim();

      if (!trimmedLine) {
        paragraphs.push(new Paragraph({ text: '' }));
        continue;
      }

      // Check if line is a header (starts with ##)
      if (trimmedLine.startsWith('##')) {
        paragraphs.push(
          new Paragraph({
            text: trimmedLine.replace('##', '').trim(),
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 400, after: 200 },
          })
        );
      }
      // Check if line is a subheader (starts with #)
      else if (trimmedLine.startsWith('#')) {
        paragraphs.push(
          new Paragraph({
            text: trimmedLine.replace('#', '').trim(),
            heading: HeadingLevel.HEADING_3,
            spacing: { before: 300, after: 150 },
          })
        );
      }
      // Check if line is a bullet point
      else if (trimmedLine.startsWith('-') || trimmedLine.startsWith('â€¢')) {
        paragraphs.push(
          new Paragraph({
            text: trimmedLine.substring(1).trim(),
            bullet: { level: 0 },
            spacing: { after: 100 },
          })
        );
      }
      // Regular paragraph
      else {
        paragraphs.push(
          new Paragraph({
            text: trimmedLine,
            spacing: { after: 200 },
          })
        );
      }
    }

    return paragraphs;
  }

  async uploadToCloudinary(buffer: Buffer, filename: string): Promise<string> {
    try {
      return new Promise((resolve, reject) => {
        cloudinary.uploader.upload_stream(
          {
            resource_type: 'raw',
            public_id: filename,
            folder: 'reports',
          },
          (error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result!.secure_url);
            }
          }
        ).end(buffer);
      });
    } catch (error) {
      console.error('Error uploading to Cloudinary:', error);
      throw new Error('Failed to upload document');
    }
  }

  async generateAndUploadReport(reportData: ReportData): Promise<string> {
    try {
      // Generate Word document
      const documentBuffer = await this.generateWordDocument(reportData);

      // Create filename
      const filename = `${reportData.clientName.replace(/[^a-zA-Z0-9]/g, '_')}_${reportData.reportPeriod.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;

      // Upload to Cloudinary
      const fileUrl = await this.uploadToCloudinary(documentBuffer, filename);

      return fileUrl;
    } catch (error) {
      console.error('Error generating and uploading report:', error);
      throw error;
    }
  }
}

export default new DocumentService();
