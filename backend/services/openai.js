const { OpenAI } = require('openai');

class OpenAIService {
  constructor() {
    this.client = null;

    if (process.env.OPENAI_API_KEY) {
      this.client = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });
    } else {
      console.warn('OpenAI API key not configured');
    }
  }

  async generateReport(timeEntries, clientName, startDate, endDate) {
    try {
      if (!this.client) {
        throw new Error('OpenAI API key not configured');
      }

      const formattedData = this.formatTimeEntriesForPrompt(timeEntries);
      const dateRange = this.formatDateRange(startDate, endDate);

      const prompt = `Generate a professional monthly status report for ${clientName} based on the following time tracking data for ${dateRange}:

${formattedData}

Please organize the report into the following sections:

1. **Completed Projects & Results**: Summarize the work completed, organized by project/task categories. Include specific achievements, deliverables, and outcomes. Focus on value delivered to the client.

2. **Action Items for TEG**: List specific tasks, follow-ups, or deliverables that the TEG team needs to complete or continue working on.

3. **Action Items for Client**: List items that require client input, approval, or action to move projects forward.

Format the output in a professional, narrative style suitable for a client-facing monthly report. Use bullet points where appropriate, and ensure the tone is professional and results-oriented.`;

      const response = await this.client.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are a professional report writer for a PR and marketing agency. Create clear, client-focused monthly status reports that highlight achievements and next steps.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 2000,
        temperature: 0.7
      });

      const generatedContent = response.choices[0]?.message?.content;

      if (!generatedContent) {
        throw new Error('No content generated by OpenAI');
      }

      return generatedContent;
    } catch (error) {
      console.error('OpenAI API error:', error);

      // Fallback to basic formatting if AI fails
      return this.generateBasicReport(timeEntries, clientName, startDate, endDate);
    }
  }

  formatTimeEntriesForPrompt(timeEntries) {
    if (!Array.isArray(timeEntries) || timeEntries.length === 0) {
      return 'No time entries found for this period.';
    }

    const formatted = timeEntries.map(entry => {
      return `• ${entry.spent_date}: ${entry.project?.name || 'Unknown'} - ${entry.task?.name || 'Unknown'} (${entry.hours}h) - ${entry.notes || 'No notes'}`;
    }).join('\n');

    return `Time Entries (${timeEntries.length} total):\n${formatted}`;
  }

  formatDateRange(startDate, endDate) {
    const start = new Date(startDate).toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
    const end = new Date(endDate).toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });

    return `${start} to ${end}`;
  }

  generateBasicReport(timeEntries, clientName, startDate, endDate) {
    const dateRange = this.formatDateRange(startDate, endDate);

    let report = `# Monthly Status Report\n\n`;
    report += `**Client:** ${clientName}\n`;
    report += `**Period:** ${dateRange}\n\n`;

    if (!timeEntries || timeEntries.length === 0) {
      report += `## Summary\n\nNo time entries recorded for this period.\n\n`;
      report += `## Action Items for TEG\n\n• Review and update time tracking processes\n\n`;
      report += `## Action Items for Client\n\n• Confirm project status and next steps\n`;
      return report;
    }

    // Group by project
    const projectGroups = {};
    let totalHours = 0;

    timeEntries.forEach(entry => {
      const project = entry.project?.name || 'General';
      if (!projectGroups[project]) {
        projectGroups[project] = [];
      }
      projectGroups[project].push(entry);
      totalHours += entry.hours || 0;
    });

    report += `## Summary\n\n`;
    report += `Total hours worked: ${totalHours}\n`;
    report += `Projects worked on: ${Object.keys(projectGroups).length}\n\n`;

    report += `## Completed Projects & Results\n\n`;
    Object.entries(projectGroups).forEach(([project, entries]) => {
      const projectHours = entries.reduce((sum, entry) => sum + (entry.hours || 0), 0);
      report += `**${project}** (${projectHours} hours)\n`;

      const tasks = [...new Set(entries.map(e => e.task?.name).filter(Boolean))];
      tasks.forEach(task => {
        report += `• ${task}\n`;
      });
      report += `\n`;
    });

    report += `## Action Items for TEG\n\n`;
    report += `• Continue work on active projects\n`;
    report += `• Prepare deliverables for client review\n\n`;

    report += `## Action Items for Client\n\n`;
    report += `• Review and provide feedback on completed work\n`;
    report += `• Approve next phase activities\n`;

    return report;
  }

  async summarizeContent(content, maxLength = 500) {
    try {
      if (!this.client || !content || content.length <= maxLength) {
        return content;
      }

      const response = await this.client.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'user',
            content: `Please summarize the following content to approximately ${maxLength} characters while maintaining key information:\n\n${content}`
          }
        ],
        max_tokens: Math.floor(maxLength / 3),
        temperature: 0.5
      });

      return response.choices[0]?.message?.content || content;
    } catch (error) {
      console.error('Content summarization error:', error);
      return content.substring(0, maxLength) + '...';
    }
  }
}

module.exports = OpenAIService;
